// 地下城游戏
//
//
// 一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿
//过地下城并通过对抗恶魔来拯救公主。
//
// 骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。
//
// 有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么
//包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。
//
// 为了尽快到达公主，骑士决定每次只向右或向下移动一步。
//
//
//
// 编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。
//
// 例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -> 右 -> 下 -> 下，则骑士的初始健康点数至少为 7。
//
//
//
// -2 (K)
// -3
// 3
//
//
// -5
// -10
// 1
//
//
// 10
// 30
// -5 (P)
//
//
//
//
//
//
// 说明:
//
//
// 骑士的健康点数没有上限。
// 任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。
//
//
// Related Topics 数组 动态规划 矩阵 👍 704 👎 0
/**
 *
 *   0     1     2
 *  -2       [-5,-5]         [-5,-2]
 *  -7       [-15,-15]       [-5,-1]
 *  [-7,3]   [-7,33]         []
 *
 * v[i,j]:历史最低血量
 * p[i,j]:当前剩余血量
 * p[i,j]上还是右:Math.max(两边最低)
 *
 */

//leetcode submit region begin(Prohibit modification and deletion)
function calculateMinimumHP(dungeon: number[][]): number {
  const m = dungeon.length;
  const n = dungeon[0].length;
  // 历史最低血量
  const v: number[][] = new Array(m).fill(1).map((p) => new Array(n).fill(0));
  // 当前剩余血量
  const p: number[][] = new Array(m).fill(1).map((p) => new Array(n).fill(0));
  // 假设从0开始
  p[0][0] = v[0][0] = dungeon[0][0];
  // 初始化首行和首列
  for (let i = 1; i < n; i++) {
    p[0][i] = dungeon[0][i] + p[0][i - 1];
    v[0][i] = Math.min(v[0][i - 1], p[0][i]);
  }
  for (let i = 1; i < m; i++) {
    p[i][0] = dungeon[i][0] + p[i - 1][0];
    v[i][0] = Math.min(v[i - 1][0], p[i][0]);
  }

  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      //从上到达
      const p1 = p[i - 1][j] + dungeon[i][j]; //剩余血量
      const v1 = Math.min(v[i - 1][j], p1); //历史最低血量
      //从左到达
      const p2 = p[i][j - 1] + dungeon[i][j];
      const v2 = Math.min(v[i][j - 1], p2);
      // 剩余血量多 历史最低血量多
      if (v1 > v2 && p1 > p2) {
        p[i][j] = p1;
        v[i][j] = v1;
      }
      // 剩余血量少，历史最低血量多
      // 剩余血量 > 历史最低血量
      // 因此

      /**
       *        -6,2->
       *   4,1   (0)
       */
    }
  }
  return Math.max(1 - v[m - 1][n - 1], 1);
}
// console.log(
//   calculateMinimumHP([
//     [-2, -3, 3],
//     [-5, -10, 1],
//     [10, 30, -5],
//   ]) === 7
// );
// console.log(
//   calculateMinimumHP([
//     [3, -3, 3],
//     [4, -10, 1],
//     [10, 30, -5],
//   ]) === 1
// );
// console.log(
//   calculateMinimumHP([
//     [3, -3, 3],
//     [4, -10, 1],
//     [10, 30, -5],
//   ]) === 1
// );
console.log(
  calculateMinimumHP([
    [1, -3, 3],
    [0, -2, 0],
    [-3, -3, -3],
  ]) === 3
);
const d1 = [
  [1, -3, 3],
  [0, -2, 0],
  [-3, -3, -3],
];
// 当前最低血量
const b1 = [
  [1, -2, 1],
  [1, -1, 0],
  [-2, -3, -3],
];
// 历史最低血量
const v1 = [
  [1, -2, -2],
  [1, -1, 0],
  [-3, -3, -3],
];
// todo: 历史血量更高，但当前血量更低，如何选择
// 取决于后续的扣血情况，如果扣血较多，需要根据扣血量和当前血量综合考虑
// 回溯最低
const r1 = [
  [-2, -3, 0],
  [-5, -5, -3],
  [-9, -6, -3],
];

// 回溯最低
const r1 = [
  [-2, 0, -9],
  [-2, -8, 9],
  [-3, -2, 0],
];
// 回溯最低
const r1 = [
  [1, 1, 0],
  [-1, 1, 9],
  [-5, -2, 0],
];

console.log(
  calculateMinimumHP([
    [5, -8, 2],
    [0, -3, 0],
    [-3, -15, -5],
  ]) === 3
);

//3
const d = [
  [5, -9, -2, -2],
  [0, -4, -3, 1],
  [-3, -9, -3, -1],
];
const b = [
  [5, -4, -6, -8],
  [5, 1, -3, 1],
  [2, -9, -2, -1],
];
//leetcode submit region end(Prohibit modification and deletion)
